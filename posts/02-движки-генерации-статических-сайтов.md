---
title: "Движки генерации статических сайтов - как я бросил эту затею (на пока?)"
date: "2021-11-07"
categories:
  - "research-development"
tags:
  - "docker"
  - "eleventy"
  - "golang"
  - "javascript"
  - "jekyll"
  - "ruby"
  - "toolset"
---

Говоря по правде, натрахался я с инструментарием статической генерации сайтов. Думал будет так: берем модные hacker-like инструменты и собираем поэтапно то что нужно. В итоге я на каждом шагу утыкаюсь в какое-нибудь полу-удивительное ограничение. Дорога будет непростой (для меня).

## **Hugo (Golang)**

Все шло хорошо, но выяснилось, что hugo пока еще не умеет в [PlantUML](https://plantuml.com/ru/). Поддержка диаграмм все еще в обсуждении — [https://github.com/gohugoio/hugo/issues/7765](https://github.com/gohugoio/hugo/issues/7765).

Есть предложенный вариант реализации, но он не подходит ментейнерам — [https://github.com/gohugoio/hugo/pull/8463](https://github.com/gohugoio/hugo/pull/8463). Уж больно в лоб решение, видимо, и не дает возможности интегрироваться с другими генераторами диаграмм.

Для меня на тот момент это было стоп-фактором — было не ясно как заставить работать эту штуку с внешними программами без патчей монолитной кодовый базы. Сам по себе код патча понятен, но не очень хотелось сидеть на форке с самого начала, как-то дерзко с учетом того, что почти каждый другой движок умеет их рисовать. А особой привязанности к hugo не было, так что я пошел искать дальше.

Кстати говоря, кому-то [go'шные шаблоны](https://gohugo.io/templates/introduction/) не нравятся, но если честно я go люблю и с шаблонами был готов работать. Если вам где-то кажется, что с go трудно, вспоминайте размер бинарника, то что бинарник вообще есть, ну и скорость исполнения и объем потребления ресурсов — меня это всегда успокаивает и воодушевляет. Флешбеки после программирования на высокоуровневых языках программирования, понимаете ли :)

## **Jekyll (Ruby)**

Родной ruby. Уж тут-то я смогу — думал я. Оказалось что ruby маркдаун процессоры не особо богаты в плане поддержки маркдаун плагинов. Ну ладно, фигня, поборемся с [kramdown](https://kramdown.gettalong.org/), тем более это официальный ruby маркдаун процессор используемый в гитхабе.

Но выяснилось, что yaml конфигурация jekyll'а не позволяет инициализировать кастомные настройки kramdown в связке с [rouge](https://github.com/rouge-ruby/rouge) (ruby syntax highlighter) и если хочешь, к примеру, не стандартного форматирования итогового кода, по версии команды jekyll'а, с сигнатурой инициализации отличающейся от дефолта — то изволь написать свою обертку и использовать ее — [https://github.com/gettalong/kramdown/issues/617](https://github.com/gettalong/kramdown/issues/617).

Беда не велика, но меня оттолкнуло это решение. Скрипты-обертки я и так постоянно пишу когда работаю с docker — какой-нибудь очередной my-app-entrypoint.sh. Заниматься таким в любимом ruby, где все так близко и под рукой мне в тот вечер не хотелось. Да и решение хотелось с лоском, а не с "хаком".

Jekyll прекрасен, но из-за того что он является движком статических страниц [Github Pages](https://pages.github.com/), не стоит ждать глобально новых фич и изменений. Сам автор jekyll'а рекомендует всем недовольным и ищущим нового смотреть на другие решения, которые находятся в фазе наращивания функционала, к примеру на [Eleventy](https://www.11ty.dev/). (К сожалению не могу найти этого issue на гитхабе, где он пишет об этом и отвечает не претензии зануд про отсутствие новых фич, но постараюсь, дабы не быть голословным и заодно перепроверить себя.)

И так я расчехлил свой джаваскриптный мозг и погнал смотреть, что из себя представляет Eleventy. А заодно откинул все варианты основанные на React ([Gatsby](https://www.gatsbyjs.com/)), так как считаю, что нельзя доверять людям, которые создали такой UX в Фейсбуке, и не стал особо заостряться на [VuePress](https://vuepress.vuejs.org/), хотя Vue.js и приятен мне.

## **Eleventy (Js)**

У Eleventy офигенный набор стартовых проектов — [https://www.11ty.dev/docs/starter/](https://www.11ty.dev/docs/starter/).

Они парятся о client-side производительности, и даже сделали рейтинговую таблицу самых быстрых шаблонов — [https://www.speedlify.dev/eleventy-starters/](https://www.speedlify.dev/eleventy-starters/). За это прям отдельное спасибо, ибо поселило в мою голову много новых заморочек.

Но я решил собрать свой сетап с нуля. Хотя и обращался к другим пакам за примерами. Webpack и прочие брокколи не интересовали, был взят [Parcel V2](https://parceljs.org), который написан на [Rust](https://www.rust-lang.org/).

#### Побеждаем сборку

Для начала пришлось научить Eleventy жить и работать в связке с Parcel, тут все просто и нам поможет [npm-run-all](https://www.npmjs.com/package/npm-run-all), который умеет запускать сразу два процесса в параллель:

Кусок из package.json:

```
"scripts": {
  "parcel": "parcel assets/*",
  "dev": "npm-run-all --parallel dev:*",
  "dev:eleventy": "ELEVENTY_ENV=development DEBUG=Eleventy* eleventy --serve",
  "dev:parcel": "parcel watch assets/* --no-cache --no-hmr --no-autoinstall --dist-dir build/assets",
  "prod": "run-s prod:*",
  "prod:eleventy": "ELEVENTY_ENV=production eleventy --output=./build_production",
  "prod:parcel": "parcel build assets/* --no-cache --dist-dir build_production/assets"
}
```

Набираем `npm run dev` и все работает (ну или `npm run prod` для итоговой сборки).

#### Внешний хайлайтер

Стандартный плагин для подсветки кода [https://www.11ty.dev/docs/plugins/syntaxhighlight/](https://www.11ty.dev/docs/plugins/syntaxhighlight/) не пропускает [markdown атрибуты](https://markdownmonster.west-wind.com/docs/_61g0yzn1y.htm), а значит передать какие-то метаданные движку подсветки невозможно.

Не беда, Eleventy отлично интегрируется с [markdown-it](https://github.com/markdown-it/markdown-it) и позволяет указать свою произвольную функцию для подсветки кода. Внутри нее я и буду вызывать внешний процесс и передавать ему нужные мне метаданные. Круто. Берем [Chroma — A general purpose syntax highlighter in pure Go](https://github.com/alecthomas/chroma) и пишем такое:

```
let markdownLibrary = markdownIt({
  html: true,
  breaks: false,
  linkify: true,

  // Наша произвольная функция подсветки:
  highlight: function(str, lang, extra) {
    var result = "empty";

    // Вызываем внешний бинарник, все флаги тут не просто так:
    // --style="autumn" — цветовая тема
    // --html-only — можно убрать, если хотите заинлайнить css
    // --html-prevent-surrounding-pre — вечнаю война с лишними тэгами в блоках кода
    // --html-highlight — цветовой акцент на определенных строках кода
    //
    // Вот здесь можно посмотреть остальные доступные флаги Chroma:
    // http://manpages.ubuntu.com/manpages/bionic/man1/chroma.1.html
    var cmd = `chroma -f html -l ${lang} \
      --style="autumn" \
      --html-only \
      --html-prevent-surrounding-pre \
      --html-highlight=${extra}
    `;
    // В extra попадет все что будет передано как атрибуты к маркдаун блоку кода.
    // Побочный эффект в том, что если передали не верно форматированные метаданные,
    // то chroma вернет ошибку, а не подсвеченный код.

    // Делаем синхронный вызов внешней программы
    result = execSync(cmd, { input: str }).toString();

    // А далее мол личный ад с \n в начале и конце блоков кода.
    // Это не красиво, но для меня сработало (на тот момент) — в лоб находу и убираю лишнее.
    result = result.replace("\n<table class=\"lntable\">", '<table class="lntable">')
    result = result.replace("<table class=\"lntable\"><tr><td class=\"lntd\">\n(\s)*", "<table class=\"lntable\"><tr><td class=\"lntd\">")
    result = result.replace("</td></tr></table>\n", "</td></tr></table>")

    return result;
  },
})
```

#### Диаграммы

Интеграция с PlantUML прошла не совсем гладко, но хочется сказать, что она-таки случилась :) Пришлось явно указать из каких маркдаун блоков цеплять код для шаблона (`openMarker/closeMarker`) и чуть доработать итоговый рендер:

```
}).use(markdownItPlantuml, {
  openMarker: '```plantuml',
  closeMarker: '```',
  render: function(tokens, idx) {
    var imageUrl = tokens[idx].attrGet('src')
    return `<div class="uml-wrapper"><img class="uml" src="${imageUrl}"></img></div>`
  }
});
```

#### Счетчик билдов

Мне захотелось, чтобы каждый билд сайта повышал внутренний счетчик — добавим некую живость нашим статичным страницам.

Визуально итогово это выглядит вот так (для пользователей):

![](https://pechorin.dev/wp-content/uploads/2021/11/Снимок-экрана-2021-11-11-в-19.56.47-1024x320.png)

Зашел на знакомый статический блог, а там счетчик вырос, значит над сайтом работали ...

И вот тут Eleventy точно молодец, не помешал моим планам никак и предоставил простой callback api для этого:

```
// После каждого билда
eleventyConfig.on("afterBuild", function() {
  // Читаем .revision файл с последней версией
  fs.readFile(".revision", "utf-8", (err, data) => {
    if (err) {
      console.log(".revision file read error:", err)
      return
    } else {
      // Повышаем версию
      var last_revision = parseInt(data)
      var new_revision = last_revision + 1

      // Перезаписываем файл
      fs.writeFile('.revision', String(new_revision), err => {
        if (err) {
          console.log(".revision file write error:", err)
          return
        }
      })
    }
  })
})
```

Eleventy имеет абстракцию [Global Data Files](https://www.11ty.dev/docs/data-global/), упрощенно говоря это данные произвольного типа и источника которые могут быть использованы при генерации вашего сайта. Это может быть как простой json файл, так и исполняемый во время сборки javascript, формирующий данные сам, либо обращающийся за ними на произвольный удаленный сервер.

Чтобы мой счетчик попал в данные доступные внутри шаблона, я создал такой global-data-file:

`data/compile_data.js`:

```
const fs = require("fs");

// Вечно остаемся в pre-1 версии :)
var BASE_REVISION = "0"

function FetchRevision() {
  var revision = BASE_REVISION
  var data = fs.readFileSync(".revision", "utf-8")
  return BASE_REVISION + "." + data
}

module.exports = {
  revision: FetchRevision()
};
```

Кусок шаблона, где видно как доставать эти данные (очень просто, название файла = название переменной):

```
<h1>pechorin andrey meta log rev {{ compile_data.revision }}</h1>
```

Пока мой revision остановился на версии ~0.2210. То есть Eleventy пересобрал сайт 2210 раз пока я работал над своим паком и парой статей. Наверное надо разделить число еще на 10, чтобы не пугать никого (себя в первую очередь).

* * *

Из минусов Eleventy — пока еще не умеет в инкрементальные билды, то есть перестраивает все дерево сайта после каждого обновления в любом файле. Не то чтобы это волновало меня на моих объемах, но это прогревало мой ноутбук при live-редактировании текста — я пишу текста в [Obsidian](https://obsidian.md/), а он синхронизирует данные на диск каждые несколько написанных символов, отсюда и такая цифра в revision'е.

> Полная версия моего почти готового конфига .eleventy.js : [https://gist.github.com/pechorin/9853d4e5ab574413434ba8a008fe28cb](https://gist.github.com/pechorin/9853d4e5ab574413434ba8a008fe28cb)

#### Как верстка подкосила меня

Успокоившись с программированием я сел за верстку. Иногда люблю этим позаниматься, особенно с настроенным [https://www.modularscale.com](https://www.modularscale.com).

Эта библиотека позволяет задать глобальную пропорцию и использовать ее для абсолютно всех размеров на сайте. Например, можно задать пропорцию [золотого сечения](https://ru.wikipedia.org/wiki/%D0%97%D0%BE%D0%BB%D0%BE%D1%82%D0%BE%D0%B5_%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5) (1.618), а затем использовать только специальную функцию с передаваемым относительным числом, чтобы увеличивать или уменьшать размер шрифта или отступа, или даже высоту блока, и не заниматься при этом математикой и вычислениями самому.

```
@import 'modularscale-sass/stylesheets/modularscale';

// Определяем пропорцию
// Я выбрал не золотое сечение, а большую секунду —
// https://en.wikipedia.org/wiki/Major_second
$modularscale: (
  base: 1em,
  ratio: 1.125
);

// Несколько примеров использования
header { font-size: ms(0); } // 1em
footer { padding: ms(3) 0; } // 1.424em 0
li { margin-right: ms(-5); } // 0.555em
```

Такой подход позволяет расслабиться и верстать пропорциональные блоки на автомате, не помня ни одного точного размера. Удобно, и мозгу легче с относительными числами, а не абсолютными. Обожаю эту библиотеку и не понимаю, почему дизайнеры до сих пор выдумывают свои кривые пропорции :) А верстальщики продолжают подхватывать их. Советовать не буду, буду буквально настаивать ознакомиться с понятием [вертикального ритма](https://8thlight.com/blog/chris-peak/2012/12/30/vertical-rhythm.html), для верстки очень полезное знание (и порой игнорируемое).

Признаюсь, хороший дизайн для меня это та еще задача даже с облегченной версткой.

После нескольких дней работы я получил вот такой результат:

![](https://pechorin.dev/wp-content/uploads/2021/11/Снимок-экрана-2021-11-11-в-20.28.59-1024x517.png)

Верстал я, верстал ... да задолбался ...

![](https://pechorin.dev/wp-content/uploads/2021/11/Снимок-экрана-2021-11-11-в-20.50.58-1024x783.png)

Что-то маловат line-height в параграфах ...

Для программиста может и норм, но я как-то не был доволен. Захотелось двигать все эти блоки руками, менять цвета быстро и через модные инструменты. Короче надоело тюнить тему через код по несколько часов и искать подходящий вариант. Чем черт не шутит, а попробую-ка я старый добрый Wordpress, мне его админка и редактор когда-то нравились. И настройка тем там в прямо в интерфейсе.

И мне, блин, понравился Wordpress, опять.

## Wordpress по-взрослому

Позволить себе просто поднять приложение на недружественном мне языке (я рубист, все-таки) я не мог. И чтобы все было Ъ, безопасно и я не потерял данные при первом же взломе через какой-нибудь вредоносный wordpress плагин (или по неопытности) я сделал следующее:

- Несколько скриптов на баше, которые разворачивают и настраивают ubuntu сервер с докером (hand made provisioning)
- Через docker compose развертывается связка wordpress/php-8/mysql-8
- Настроил свои ежедневные backup и restore скрипты с уведомлениями в телеграмм

В итоге я могу переехать на новый хост с полным восстановлением состояния буквально за несколько минут.

Но обо всем этом в деталях я опишу уже в следующем посте своего docker & bash путешествия.

А пока я редактирую этот пост в визуальном редакторе wordpress'а и мне нравится. Отрицать что и на php могут быть классные продукты уже как-то высокомерно в моем возрасте. Хотя, понятно, тут хватает своего треша.
